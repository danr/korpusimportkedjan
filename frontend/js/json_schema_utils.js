// Generated by CoffeeScript 1.4.0

/*
Follows internal json schema references, i.e. objects of type
   { "$ref": "#/segmenters" },
which means replace this object with the attribute segmenters
from the top schema. Arrays and objects are traversed in the schema,
which gets mutated, and eventually returned. Cyclic references
voids termination.
*/


(function() {
  var flatten_singleton_unions, follow_references, get_default;

  follow_references = function(schema) {
    var rec;
    rec = function(pos) {
      var addr, i, key, ref, relocate, _base, _i, _len, _ref, _ref1, _results;
      _results = [];
      for (key in pos) {
        ref = pos[key]["$ref"];
        if ((ref != null) && ref.slice(0, 2) === "#/") {
          relocate = schema;
          _ref = ref.slice(2).split('/');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            addr = _ref[_i];
            relocate = relocate[addr];
          }
          delete pos[key]["$ref"];
          for (i in relocate) {
            if ((_ref1 = (_base = pos[key])[i]) == null) {
              _base[i] = relocate[i];
            }
          }
        }
        if ((_.isArray(pos[key])) || _.isObject(pos[key])) {
          _results.push(rec(pos[key]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    rec(schema);
    return schema;
  };

  /*
  # Gets a value of the gives schema populated with the default values specified in it
  */


  get_default = function(schema) {
    if (schema.type === "object" && !schema["default"]) {
      return _.object(_.map(schema.properties, function(subschema, key) {
        return [key, get_default(subschema)];
      }));
    } else {
      return schema["default"];
    }
  };

  /*
  # Flattens out union types of only one type
  */


  flatten_singleton_unions = function(schema) {
    var key, subschema, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    if (_.isArray(schema.type) && schema.type.length === 1) {
      for (key in schema.type[0]) {
        if ((_ref = schema[key]) == null) {
          schema[key] = schema.type[0][key];
        }
      }
      schema.type = schema.type[0].type;
    }
    if (schema.properties != null) {
      for (key in schema.properties) {
        flatten_singleton_unions(schema.properties[key]);
      }
    }
    if (schema.items != null) {
      _ref1 = schema.items;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        subschema = _ref1[_i];
        flatten_singleton_unions(subschema);
      }
    }
    if (_.isArray(schema.type)) {
      _ref2 = schema.type;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        subschema = _ref2[_j];
        flatten_singleton_unions(subschema);
      }
    }
    return schema;
  };

  /*
  # Export in the json_schema_utils namespace
  */


  window.json_schema_utils = {
    follow_references: follow_references,
    get_default: get_default,
    flatten_singleton_unions: flatten_singleton_unions
  };

}).call(this);
