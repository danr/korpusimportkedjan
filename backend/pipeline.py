# -*- coding: utf-8 -*-

from xml.sax.saxutils import escape
from Queue import Queue

import threading

import errno
import os

import sb.util as util

from make_makefile import makefile

def enum(*sequential, **named):
    """
    Makes an enumerator type: http://stackoverflow.com/a/1695250/165544
    """
    enums = dict(zip(sequential, range(len(sequential))), **named)
    return type('Enum', (), enums)

"""The possible statuses of a pipeline"""
Status = enum('Init', 'Running', 'Done', 'Error')

"""The possible message types from the pipeline"""
Message = enum('StatusChange', 'Increment', 'IncrementHeader', 'IncrementFooter')

def finished(status):
    """The statuses that comprise a finished build"""
    return status == Status.Done or status == Status.Error

def make_hash(text, makefile):
    """
    The text is hashed together with its makefile because the built corpus
    will look different on many settings. For example, if word annotations
    are taken from the corpus or generated by our tools.
    """
    import hashlib
    return hashlib.sha1(text + makefile).hexdigest()

def make(settings):
    from subprocess import Popen, PIPE
    util.log.info("CALL: /usr/bin/make %s", ' '.join(settings))
    return Popen(['/usr/bin/make'] + settings,
                 shell=False, close_fds=False,
                 stdin=None, stdout=PIPE, stderr=PIPE)

def mkdir(d):
    try:
        os.makedirs(d, mode=0777)
    except OSError as exc:

        if exc.errno == errno.EEXIST:
            pass
        else:
            raise
    util.system.call_binary('chmod', ['777', d, '-v'])

def rmfile(f):
    try:
        os.remove(f)
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            pass
        else:
            raise

def make_trace():
    from sys import exc_type, exc_value, exc_traceback
    import traceback
    return "".join(traceback.format_exception(exc_type, exc_value, exc_traceback))

class Build(object):
    def __init__(self, pipeline, text, settings):
        """
        Creates the necessary directories and the makefile for this
        file. Returns the hash and the directory the pipeline runs on
        """

        self.queues = []

        self.text = text
        self.makefile_contents = makefile(settings)

        self.build_hash = make_hash(self.text, self.makefile_contents)

        self.pipeline = pipeline
        self.settings = settings

        self.status = None

        # Output from make, line by line
        self.make_out = []

    def increment_header(self):
        """The increment header message"""
        return '<incremental steps="%s">\n' % self.steps

    def increment_msg(self):
        """The current increment message"""
        return '<increment command="%s">%s</increment>\n' % (self.command, self.step)

    def increment_footer(self):
        """The increment footer message"""
        return '</incremental>\n'

    def send_to_all(self, msg):
        """Sends a message to all listeners"""
        map(lambda q: q.put(msg), self.queues)

    def change_status(self, status):
        """Change the status and notify all listeners"""
        self.status = status
        self.send_to_all((Message.StatusChange, self.status))

    def notify_increment_running(self):
        """Notify that we have started running and inform how many steps we will take"""
        self.send_to_all((Message.IncrementHeader, self.increment_header()))

    def notify_step(self):
        """Notifies all listeners that the increment has been increased"""
        self.send_to_all((Message.Increment, self.increment_msg()))

    def notify_increment_completion(self):
        """Notify completion, by sending a </increment>"""
        self.send_to_all((Message.IncrementFooter, self.increment_footer()))

    def make_files(self):
        """
        Makes the files for building this corpus:
        directories, the original corpus and the makefile
        """
        self.change_status(Status.Init)

        self.directory = os.path.join(self.pipeline['dir'], self.build_hash)

        self.original_dir = os.path.join(self.directory, 'original')
        self.annotations_dir =  os.path.join(self.directory, 'annotations')
        self.export_dir = os.path.join(self.directory, 'export')
        self.warnings_log_file = os.path.join(self.directory,'warnings.log');

        self.makefile = os.path.join(self.directory, 'Makefile')

        self.text_file = os.path.join(self.original_dir, 'text.xml')

        # Make directories
        map(mkdir, [self.original_dir, self.annotations_dir])

        # Make makefile
        with open(self.makefile, 'w') as m:
            m.write(makefile(self.settings))

        if os.path.isfile(self.text_file):
            # This file has probably been built by a previous incarnation of the pipeline
            # (index.wsgi script has been restarted)
            util.log.info("File exists and is not rewritten: %s", self.build_hash)
        else:
            with open(self.text_file, 'w') as f:
                f.write(self.text)

    def _run(self, fmt):
        """
        Run make, sending increments, and eventually obtaining the built corpus
        """
        make_settings = ['-C', self.directory,
                         'dir_chmod=777',
                         '-j', str(self.pipeline['processes']),
                         "python=%s" % self.pipeline['python']]

        if fmt == 'vrt' or fmt == 'cwb':
            make_settings = [fmt] + make_settings
            self.out_file = os.path.join(self.annotations_dir, 'text.vrt')
        else:
            make_settings = ['export'] + make_settings
            self.out_file = os.path.join(self.export_dir, 'text.xml')

        # Do a dry run to get the number of invocations that will be made
        stdout, _ = make(make_settings + ['--dry-run']).communicate("")
        self.steps = stdout.count("catalaunch")

        # Start make for real
        process = make(make_settings)

        self.step = 0
        self.command = ""
        self.change_status(Status.Running)

        # Process the output from make
        self.notify_increment_running()
        for line in iter (process.stdout.readline, ''):
            # print line.rstrip()
            self.make_out += [line]
            if "catalaunch" in line:
                self.step += 1;
                self.command = line.split(" ")[3]
                self.notify_step()
        self.notify_increment_completion()

        # Send warnings
        try:
            with open(self.warnings_log_file, "r") as f:
                self.warnings = f.read().rstrip()
        except IOError as e:
            self.warnings = None

        # Store the completed corpus
        with open(self.out_file, "r") as f:
            self.corpus = f.read()

        self.change_status(Status.Done)

    def run(self, fmt):
        """
        Runs make, catching errors
        """
        self.trace, self.stdout, self.stderr = ("", "", "")

        try:
            self._run(fmt)
        except:
            self.trace = make_trace()
            print self.trace
            self.stdout = "\n".join(self.make_out)
            self.stderr = process.stderr.read().rstrip()
            self.change_status(Status.Error)

    def result(self):
        """
        Returns the result: either a built corpus with possible warning messages,
        or the error messages for an unsuccessful build
        """
        assert(self.status == Status.Done or self.status == Status.Error)
        if self.status == Status.Done:
            out = []
            self.warnings and out.append('<warning>' + escape(self.warnings) + '</warning>')
            out.append(self.corpus)
            return "\n".join(out)
        else:
            out = []
            out.append('<trace>' + escape(self.trace) + '</trace>')
            out.append('<stderr>' + escape(self.stderr) + '</stderr>')
            out.append('<stdout>' + escape(self.stdout) + '</stdout>')
            return "\n".join(out) + "\n"
